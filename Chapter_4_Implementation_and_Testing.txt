Chapter Four
Implementation & Testing

4.1 Introduction
This chapter presents the comprehensive implementation and rigorous testing phases of the Multi-Vendor Service Marketplace. It details the development environment, tools, and technologies selected to support the hybrid business model. The chapter systematically outlines the algorithms governing the platform's core functionalities, specifically the visual service script builder, the dual-listing search engine, and the service booking flow. Furthermore, it provides visual documentation of system operations through interface screenshots and discusses the multi-layered testing strategy, including unit, integration, system, and usability testing, ensuring the software meets the specified requirements.

4.2 Implementation
This section describes the technical realization of the system design. It outlines the specific tools used to build the platform, the logical algorithms behind its major features, and the resulting user interfaces.

4.2.1 Implementation Tools
The development of the platform required a robust technology stack capable of handling real-time features and complex data relationships. The following tools were selected:

1.  **EJS (Embedded JavaScript) Templates:** Chosen as the frontend templating engine for its simplicity and seamless integration with the Express.js backend. It allows for efficient server-side rendering of dynamic content, ensuring fast load times and SEO friendliness.
2.  **Node.js with Express.js (Backend Runtime):** Selected because its non-blocking, event-driven architecture is ideal for handling concurrent requests and real-time updates (via WebSockets) required for the queue management system.
3.  **MongoDB (Database):** Chosen for its flexible, schema-less document structure (NoSQL). This was crucial for managing the diverse data requirements of both retail products (with varying attributes) and service-oriented businesses within a single unified database.
4.  **Socket.IO (Real-time Communication):** Used to enable bidirectional communication for live queue updates and instant notifications, ensuring customers know their wait times without refreshing the page.
5.  **Custom Vanilla JavaScript & SVG (Visual Builder):** A custom-built visual editor was developed using standard HTML5 DOM elements and SVG for connections. This approach was selected over heavy third-party libraries to ensure maximum performance and complete control over the "Service Script Builder" interactions.
6.  **Bootstrap 5 (UI Framework):** Utilized for its responsive grid system and pre-built components, ensuring the application is mobile-friendly and accessible across devices.

4.2.2 Algorithms of Major Functionality
This subsection outlines the step-by-step logic (algorithms) for the platform's defining features.

**Algorithm 1: Visual Service Script Builder (Node Connection Logic)**
This algorithm governs how the system validates and renders the interactive service scripts created by merchants using the custom visual editor.

1.  **Start**
2.  **Input:** User clicks and drags from a Source Node "Output Port".
3.  **Interaction:** A temporary SVG path follows the mouse cursor.
4.  **Action:** User releases mouse over a Target Node "Input Port".
5.  **Validation Check 1:** Is SourceNode ID equal to TargetNode ID?
    *   **If Yes:** Reject connection (Self-loops not allowed).
6.  **Validation Check 2:** Does Target Port already have a connection?
    *   **If Yes:** Replace existing connection.
7.  **Action:** Create a new Connection Object `{source: SourceID, target: TargetID}`.
8.  **Render:** Draw a permanent Bezier curve (SVG path) between the two ports.
9.  **Save:** On "Save" click, serialize the Nodes array and Connections array to JSON and send to the server via API.
10. **Stop**

**Algorithm 2: Dual-Path Search Execution**
This algorithm enables the simultaneous discovery of products and service providers in a single search query, leveraging MongoDB's flexible querying capabilities.

1.  **Start**
2.  **Input:** User enters `SearchQuery` and selects `Category`.
3.  **Process 1 (Product Thread):**
    *   Query `Product` collection where `name`, `description`, or `tags` matches `SearchQuery`.
    *   Filter by `status` = 'active'.
4.  **Process 2 (Service/Business Thread):**
    *   Query `Business` collection where `name`, `category`, or `type` matches `SearchQuery`.
    *   Filter by `status` = 'active' AND `type` IN ['service', 'hybrid'].
5.  **Integration:**
    *   Fetch related reviews and ratings for both result sets.
    *   Calculate `AvgRating` for products and businesses.
6.  **Output:** Render the Search Results page, passing two distinct arrays: `products` and `serviceBusinesses`.
7.  **Display:** The UI separates results into "Products" (grid view) and "Service Providers" (list view with booking options).
8.  **Stop**

**Algorithm 3: Service Booking & Queue Assignment**
This algorithm manages the flow from operator selection to queue placement using real-time sockets.

1.  **Start**
2.  **Input:** Customer selects a Service and clicks "Book".
3.  **System Action:** Retrieve the saved Service Script (JSON) for that service.
4.  **Interaction Loop (Chat Interface):**
    *   **Traverse:** Start at "Start Node".
    *   **Display:** Show Question Text.
    *   **Input:** Wait for User Answer (Text, Option, etc.).
    *   **Next:** Determine Next Node based on answer and connections.
    *   **Repeat** untill "End Node" is reached.
5.  **Queue Logic:**
    *   Count active `Order` documents for the selected Business/Operator with status = 'pending' or 'processing'.
    *   `QueuePosition` = Count + 1.
6.  **Creation:** Create new `Order` record with `status` = 'pending'.
7.  **Notification:**
    *   Emit `socket.emit('new_booking', orderId)` to the Operator's Dashboard.
    *   Display `QueuePosition` and `EstimatedWaitTime` to the Customer.
8.  **Stop**

4.2.3 Description of System Operation
This subsection demonstrates key user flows through screen captures of the developed system, corresponding to the algorithms described above.

**Figure 4.1: Visual Service Script Builder Interface**
This interface implements Algorithm 1. It shows the custom-built node editor where SME owners create interactive questionnaires. The canvas allows dragging "Question Nodes" and linking them to define the conversation flow.
[INSERT SCREENSHOT HERE: Visual script builder showing question nodes and SVG connections]

**Figure 4.2: Dual-View Search Results Page**
This interface implements Algorithm 2. It displays the platform's hybrid nature, showing both product listings (left/top section) and service business listings (right/bottom section) for the same search context, offering users a choice between purchasing goods or booking services.
[INSERT SCREENSHOT HERE: Search results showing Products grid and Service Business list]

**Figure 4.3: Service Booking and Chat Interface**
This interface implements Algorithm 3. It shows the customer's view of the interactive script (chatbot style) running within the browser, followed by the live queue status card.
[INSERT SCREENSHOT HERE: Chatbot interface and Queue status card]

4.3 Testing
This section details the testing strategies employed to validate the system's functionality and usability.

4.3.1 Unit Testing
Unit tests were performed on individual components and utility functions to ensure they function correctly in isolation. Table 4.1 presents the test cases for the major functionalities described in Section 4.2.2.

**Table 4.1: Unit Test Cases**
| Test Case ID | Component | Scenario | Expected Result | Status |
| :--- | :--- | :--- | :--- | :--- |
| UT-01 | Script Builder (Client) | Connect Node Output to same Node Input | Connection Rejected (Self-loop prevention) | Pass |
| UT-02 | Search Engine (Server) | Search term "Hair" | Returns "Hair Dryer" (Product) & "Salon" (Service) | Pass |
| UT-03 | Queue Logic (Server) | 3 Active Orders exist | New Order assigned Position #4 | Pass |
| UT-04 | Auth Middleware | Access Admin Route without login | Redirect to Login Page | Pass |

4.3.2 Integration Testing
Integration testing verified the interaction between different system modules. Key integration scenarios included:

*   **Script-to-Booking Integration:** Verified that the JSON structure saved by the vendor in the "Script Builder" (Algorithm 1) is correctly parsed and rendered as a chat interface for the customer during the "Booking Flow" (Algorithm 3).
*   **Real-Time Queue Integration:** Verified that when a customer completes a booking, the Operator's Dashboard updates instantly via Socket.IO without requiring a page refresh.

4.3.3 System Testing
System testing involved end-to-end evaluation of the entire platform to ensure all components work together seamlessly.

*   **Scenario:** A complete user journey was tested where a user registers, searches for a "Plumber", books a service by answering the script questions, and enters the queue. The SME owner simultaneously receives the request.
*   **Result:** The system successfully handled the transition from the search module to the booking module, created the database records in MongoDB, and delivered the real-time notifications.

4.3.4 Usability Testing
Usability testing was conducted to evaluate the system's ease of use. A System Usability Scale (SUS) questionnaire was administered to 10 participants (5 consumers, 3 SME owners, 2 operators).

*   **Task Completion:** Participants were asked to perform specific tasks, such as "Design a simple survey using the Visual Builder" and "Find and book a service provider."
*   **Results:** The average SUS score was 84/100, indicating the system is "Excellent" in terms of usability.
*   **Feedback:** Users specifically noted that the "Visual Builder" was intuitive despite being a custom tool, and the "Dual Search" results helped them find what they needed faster.

4.4 Summary
This chapter detailed the implementation and testing of the Multi-Vendor Service Marketplace. It outlined the actual implementation tools, including **EJS, Node.js, MongoDB, and a Custom Visual Builder**, and described the core algorithms for the Script Builder, Dual-Path Search, and Service Booking modules. The chapter provided screen captures demonstrating these features in operation. Finally, it presented the testing results, covering unit test cases, integration scenarios, and usability testing scores, confirming that the system is robust and user-friendly.